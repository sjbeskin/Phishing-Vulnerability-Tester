import sqlite3
import os
import uuid

TABLE_NAME : str = "VulnerabilityTesterDB.db"
TEST_TABLE_NAME : str = "TestingDB.db"

# Class for email recipients storing email address and organization name
class Recipient:
    def __init__(self, email : str, organization_name : str):
        self.email = email
        self.organization_name = organization_name

class SQLConnector:
    
    def __init__(self, testing_mode : bool = False):
        self.testing_mode = testing_mode

        
        #In testing mode, always delete the existing tester database to ensure the same results every time.

        db_filename : str
        if self.testing_mode:
            try:
                os.remove(TEST_TABLE_NAME)
            except:
                pass
            db_filename = TEST_TABLE_NAME
        else:
            db_filename = TABLE_NAME

        #Connect to db, creating it if it does not exist
        connection = sqlite3.connect(db_filename) 
        crsr = connection.cursor()

        #Look up if the organizations table already exists, create it if not
        crsr.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='organizations';")
        if (len(crsr.fetchall()) == 0):
            
            #Create the organizations table
            create_table_command = """CREATE TABLE organizations (
            uuid VARCHAR(128) PRIMARY KEY,
            organization_email VARCHAR(128) NOT NULL UNIQUE,
            organization_name VARCHAR(128) NOT NULL,
            scam_clicks INT
            );"""

            crsr.execute(create_table_command)
            print(f"[TESTING MODE: {self.testing_mode}]Created fresh db")
        else:
            print(f"[TESTING MODE: {self.testing_mode}]Created fresh db")


        #Commit and close
        connection.commit()
        connection.close()

    def get_organization_rows(self, organization : str) -> list[list[str, int]]: 
        connection : sqlite3.Connection
        if self.testing_mode:
            connection = sqlite3.connect(TEST_TABLE_NAME)
        else:
            connection = sqlite3.connect(TABLE_NAME) 
        crsr = connection.cursor()

        #Query database for all rows matching supplied organization
        crsr.execute(f"SELECT organization_email, scam_clicks FROM organizations WHERE organization_name='{organization}'")
        query_result = crsr.fetchall()

        #Commit and close
        connection.commit()
        connection.close()

        return query_result
    def get_recipient(self, recipient_email : str):
        connection : sqlite3.Connection
        if self.testing_mode:
            connection = sqlite3.connect(TEST_TABLE_NAME)
        else:
            connection = sqlite3.connect(TABLE_NAME) 
        crsr = connection.cursor()

        #Query database for all rows matching supplied email
        crsr.execute(f"SELECT * FROM organizations WHERE organization_email='{recipient_email}'")
        query_result = crsr.fetchall()

        #Commit and close
        connection.commit()
        connection.close()

        #List contains at most 1 elements since emails are unique, just return the topmost element or None
        if (len(query_result)):
            return query_result[0]
        return None
    def add_recipients(self, recipients : list[Recipient]):
        
        connection : sqlite3.Connection
        if self.testing_mode:
            connection = sqlite3.connect(TEST_TABLE_NAME)
        else:
            connection = sqlite3.connect(TABLE_NAME) 
        crsr = connection.cursor()

        try:
            for r in recipients:
                user_id = uuid.uuid4()
                query = f"""INSERT INTO organizations (uuid, organization_email, organization_name, scam_clicks) 
                VALUES ('{user_id}', '{r.email}', '{r.organization_name}', 0);"""

                crsr.execute(query)
        except sqlite3.IntegrityError: 
            print("User already existed in table")
        except:
            print("Failed to add user")
        #Commit and close
        connection.commit()
        connection.close()

    def get_organization_names(self) -> list[str]: 
        connection : sqlite3.Connection
        if self.testing_mode:
            connection = sqlite3.connect(TEST_TABLE_NAME)
        else:
            connection = sqlite3.connect(TABLE_NAME) 
        crsr = connection.cursor()

        crsr.execute("SELECT DISTINCT organization_name FROM organizations")
        organization_names = []

        organization_names_tuple = crsr.fetchall()
        for o in organization_names_tuple:
            organization_names.append(o[0])
        connection.close()
        return organization_names    

    def register_recipient_scam_click(self, uuid : str):
        connection : sqlite3.Connection
        if self.testing_mode:
            connection = sqlite3.connect(TEST_TABLE_NAME)
        else:
            connection = sqlite3.connect(TABLE_NAME) 
        crsr = connection.cursor()

        #search for recipient with given uuid
        crsr.execute(f"SELECT * FROM organizations WHERE uuid='{uuid}'")
        clicks : int
        query_result = crsr.fetchall()
        if (query_result):
            if len(query_result[0]) == 4:
                clicks = query_result[0][3]
            else: 
                #invalid row
                print("invalid row")
                return
        else:
            #user does not exist
            print("User does not exist")
            return
        clicks += 1

        #write new clicks number to db
        crsr.execute(f"UPDATE organizations SET scam_clicks={clicks} WHERE uuid='{uuid}'")
        
        #Commit and close
        connection.commit()
        connection.close()

    
if __name__ == "__main__":
    #Reset db
    try:
        os.remove(TABLE_NAME)
    except:
        print("Could not find db to remove")